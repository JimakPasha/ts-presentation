- Объединение, пересечение 
- Типизация объектов
- Разница между void, never, unknown, any
- Тайпдеф файлы
- Можно ли автоматизировать типизацию сложных, вложенных, длинных объектов
- Типизация редакс

=========================================================================
Объединение (юнион типы) // https://www.youtube.com/watch?v=6H2liQHFQWE&list=PL51FNaeWDci7CPQ-5BiqeFd6hfRWY_c6d&index=5&ab_channel=Frontend%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0SPA

=========================================================================
Другие типы, о которых следует знать

=====
void
Void это значение, возвращаемое функцией, которая ничего не возвращает. Если в теле функции отсутствует оператор return или после этого оператора не указано возвращаемого значения, предполагаемым типом возвращаемого значения будет void:

function fn() {
  return
}

function fn() {
  console.log('Hello!')
}

В JS функция, которая ничего не возвращает, "неявно" возвращает undefined. Однако, в TS void и undefined - это разные вещи.

=====
any

=====
???unknown
Тип unknown представляет любое значение. Он похож на тип any, но является более безопасным, поскольку не позволяет ничего делать с неизвестным значением

function f1(a: any) {
  a.b() // OK
}

function f2(a: unknown) {
  a.b()
  // Object is of type 'unknown'.
  // Типом объекта является 'unknown'
}

Это бывает полезным для описания типа функции, поскольку таким способом мы можем описать функцию, принимающую любое значение без использования типа any в теле функции. Другими словами, мы можем описать функцию, возвращающую значение неизвестного типа:

function safeParse(s: string): unknown {
  return JSON.parse(s)
}

const obj = safeParse(someRandomString)

=====
never
Некоторые функции никогда не возвращают значений:
Тип never представляет значение, которого не существует. Чаще всего, это означает, что функция выбрасывает исключение или останавливает выполнение программы.

function fail(msg: string): never {
  throw new Error(msg)
}

function fn(x: string | number) {
  if (typeof x === 'string') {
    // ...
  } else if (typeof x === 'number') {
    // ...
  } else {
    x // типом `x` является `never`!
  }
}


=========================================================================


Вопросы:

// разница между Object и object
object представляет все не приметивные значения. object только {} 
Object описывает функциональность описанную для всех js объектов toString, hasOwnProperty (для object они будут не доступны). Object можно = 1

// отличия tuple от array

// что мы можем присвоить в переменную у которой тип void?

// валидно? function foo():void {
  return
}

// как понимаешь что такое тип строкового литерала через объединение? можешь написать пример

// let x1: Number = new Number(1);
let x2: Number = 1;
console.log(x1)
console.log(x2)
в чём разница будет?
как достать из x1 значение?

// чем абстратный класс отличается от интерфейса?
(классы могут содержать какую-то дефолтную реализацию, у интерфейсов не может быть реализации методов)

// для чего нужен тип Omit
(Это новый тип, в котором можно указать свойства, которые будут исключены из исходного типа.)

// для чего нужен тип Pick
(Это новый тип, в котором можно указать свойства, которые будет добавлено к исходному типу.)

// Required
(делает все свойства типа обязательными)

// для чего нужно использовтаь ключевое слово declare

// Как перегрузить функцию?

// Что такое «.map» файл, как и зачем его использовать?

свйоство системы иметь несколько реазиаций одного интерфейса
класс наследника имеет возможность корректировать реализацию метода класса родителя